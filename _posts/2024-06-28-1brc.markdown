# Rust 1 Billion Row Challenge without Dependencies

## Introduction

On January 1st, 2024, [Gunnar Morling announced](https://www.morling.dev/blog/one-billion-row-challenge/) the 1 Billion Row Challenge (1BRC). The challenge consists on write a Java program for retrieving temperature measurement values from a text file and calculating the min, mean, and max temperature per weather station. Thereâ€™s just one caveat: the file contains 1,000,000,000 rows.


The text file has a simple structure with one measurement value per row:

```
Graus;12.0
Zaragoza;8.9
Madrid;38.8
Paris;15.2
London;12.6
...
```

The program should print out the min, mean, and max values per station, ordered alphabetically like so:

```
{Graus=5.0/18.0/27.4, Madrid=15.7/26.0/34.1, New York=12.1/29.4/35.6, ...}
```

Out of curiosity, I read several implementations in Rust. They were really good and optimized, and I learned a lot from them. However, they did not follow one of the rules of the 1BRC: no external dependencies may be used.


I tried running the [official Rust solution](https://1brc.dev/) with my 1 billion rows test file on my [SER5 MAX mini PC](https://www.bee-link.com/products/beelink-ser5-max-5800h?variant=46189745766642). It took **5.7 seconds** to execute.


I decided to write my own solution in Rust without using any external crates. My goal was to achieve similar performance to the official solution while keeping the code simple and short.

The code is [available on this Github repository](https://github.com/RPallas92/one-billion-row).

## Base Naive Implementation

I started by writing a simple, naive and unoptimized first version to use it as a base implementation for further improvements.


```rust
use std::{
    collections::BTreeMap,
    fmt::Display,
    fs::File,
    io::{BufRead, BufReader, Result},
    time::Instant,
};

fn main() {
    /*
    The release build is executed in around 90 seconds on SER5 MAX:
       - CPU: AMD Ryzen 7 5800H with Radeon Graphics (16) @ 3.200GHz
       - GPU: AMD ATI Radeon Vega Series / Radeon Vega Mobile Series
       - Memory: 28993MiB
    */
    let start = Instant::now();

    let reader = get_file_reader().unwrap();
    let station_to_metrics = build_map(reader).unwrap();
    print_metrics(station_to_metrics);

    let duration = start.elapsed();
    println!("\n Execution time: {:?}", duration);
}

fn get_file_reader() -> Result<BufReader<File>> {
    let file: File = File::open("./data/weather_stations.csv")?;
    Ok(BufReader::new(file))
}

fn build_map(file_reader: BufReader<File>) -> Result<BTreeMap<String, StationMetrics>> {
    let mut station_to_metrics = BTreeMap::<String, StationMetrics>::new();
    for line in file_reader.lines() {
        let line = line?;
        let (city, temperature) = line.split_once(';').unwrap();
        let temperature: f32 = temperature.parse().expect("Incorrect temperature");
        station_to_metrics
            .entry(city.to_string())
            .or_default()
            .update(temperature);
    }
    Ok(station_to_metrics)
}

// BTreeMap already sorts keys in ascending order.
fn print_metrics(station_to_metrics: BTreeMap<String, StationMetrics>) {
    for (i, (name, state)) in station_to_metrics.into_iter().enumerate() {
        if i == 0 {
            print!("{name}={state}");
        } else {
            print!(", {name}={state}");
        }
    }
}

#[derive(Debug)]
struct StationMetrics {
    sum_temperature: f64,
    num_records: u32,
    min_temperature: f32,
    max_temperature: f32,
}

impl StationMetrics {
    fn update(&mut self, temperature: f32) {
        self.max_temperature = self.max_temperature.max(temperature);
        self.min_temperature = self.min_temperature.min(temperature);
        self.num_records += 1;
        self.sum_temperature += temperature as f64;
    }
}

impl Default for StationMetrics {
    fn default() -> Self {
        StationMetrics {
            sum_temperature: 0.0,
            num_records: 0,
            min_temperature: f32::MAX,
            max_temperature: f32::MIN,
        }
    }
}

impl Display for StationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let avg_temperature = self.sum_temperature / (self.num_records as f64);
        write!(
            f,
            "{:.1}/{avg_temperature:.1}/{:.1}",
            self.min_temperature, self.max_temperature
        )
    }
}

```

As simple as this:
1. It opens the CSV file `./data/weather_stations.csv` and creates a buffered reader for efficient file reading.
1. It reads each line of the file, splitting each line into a city name and a temperature value. It uses a BTreeMap to store and update temperature statistics (min, mean, and max) for each city. The BTreeMap automatically keeps the city names sorted.
1. For each city, it has a StationMetrics struct that tracks the sum, count, min, and max temperatures. The implementation updates these metrics as it processes each line of the file.
1. Once all data is processed, we print the temperature statistics for each city.

It is executed in **90 seconds** on my mini PC. This is too far from the 5.7 seconds of the official implementation. Let's get started!


I also wrote this script to create a sample test file to try against:
 *<details><summary>See code of the script</summary>*
>
```rust
use std::fs::{self, File};
use std::io::{BufWriter, Write};
use std::path::Path;

fn main() {
    // The file created will have the following structure:
    // Each line will contain a city name and a temperature separated by a semicolon.
    // Format: CityName;Temperature
    // Example: Zaragoza;26.0

    let cities = [
        "Zaragoza",
        "Madrid",
        "Graus",
        "Torrelabad",
        "Las Vegas",
        "New York",
        "Paris",
        "London",
    ];

    let temperatures = [
        -5.0, 0.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, -4.5, 1.0, 6.5, 11.0, 16.0, 21.5,
        26.0, 31.0, 36.0, 41.5,
    ];

    let dir_path = Path::new("./data");
    if !dir_path.exists() {
        fs::create_dir_all(dir_path).unwrap();
    }

    let file = File::create(dir_path.join("weather_stations.csv")).unwrap();
    let mut writer = BufWriter::new(file);

    let num_entries = 1_000_000_000;
    for i in 0..num_entries {
        let city = cities[i % cities.len()];
        let temperature = temperatures[i % temperatures.len()];
        writeln!(writer, "{};{:.1}", city, temperature).unwrap();
    }
}
```
</details>

In the repository, you can execute it by running `cargo run --bin create_data_file`.


To be continued.






